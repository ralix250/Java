Notas Java

   James Gosling: Escribelo 1 vez y ejecutalo donde quieras.
   1. Introducción
      https://www.oracle.com/mx/java/technologies/downloads/
      Instalar Java, agregar variable de entorno(JAVA_HOME) y variable PATH(ruta donde esta instalado el jdk)
      https://www.jetbrains.com/idea/
      Instalar IntelliJ IDEA
      ### Origen y desarrollo de Java
         Java fue desarrollado por **Sun Microsystems** en **1995**, aunque su origen se remonta a **1991**, cuando un equipo de 13 personas liderado por **James Gosling** inició el **Proyecto Verde** (Green Project).
         Buscaba crear un lenguaje para desarrollar aplicaciones para tarjetas inteligentes y decodificadores de TV.
         Inicialmente, usaron el lenguaje **C++**, pero los problemas con punteros y gestión de memoria llevaron a la necesidad de desarrollar un nuevo lenguaje desde cero.
         El primer nombre del lenguaje fue **Oak** (Roble), en honor al árbol que James Gosling veía desde su ventana.
         Sin embargo, por temas de licencias tuvieron que cambiar el nombre a **Java**, inspirado en una cafetería frecuentada por el equipo, ubicada en la isla de Java, Indonesia.
      ### Lanzamiento oficial
         - **1995**: Primera versión oficial del lenguaje.
         - **1996**: Lanzamiento oficial ante la prensa y creación de un navegador que permitía ejecutar pequeños programas llamados **applets** en páginas web (hoy obsoletos).
         - **1998-1999**: Nace **Java Enterprise Edition (JEE)**, enfocado en el desarrollo de aplicaciones empresariales y dinámicas.
      ### Filosofía y características principales de Java
         La visión de Gosling era desarrollar un lenguaje **multiplataforma**, cuyo lema era: *"Escríbelo una vez, ejecútalo en cualquier lugar"*.
         Esta independencia se logra gracias a la **Máquina Virtual de Java (JVM)**, que permite que los binarios compilados (bytecode) puedan ejecutarse en diferentes sistemas operativos (Linux, Windows, macOS).
         Cada sistema operativo tiene su propia JVM, lo que hace posible la ejecución del bytecode sin importar la plataforma.
      ## Características clave de Java
         1. **Multiplataforma**: Las aplicaciones se compilan en **bytecode**, un lenguaje intermedio que la JVM convierte en binario para ser interpretado por el hardware.
         2. **Orientación a objetos**: Java sigue los principios de la **Programación Orientada a Objetos (POO)**, incluyendo:
            - **Polimorfismo**: Clases que pueden adoptar múltiples formas mediante la herencia.
            - **Encapsulamiento**: Permite ocultar información interna de las clases.
            - **Herencia**: Reutilización de atributos y métodos de una clase padre en otras clases.
            - **Interfaces**: Especifican un contrato que las clases deben seguir.
            - **Sobrecarga y sobrescritura de métodos**: Dos formas de implementar métodos con el mismo nombre pero diferentes comportamientos.
         3. **Recolección automática de basura**: Un proceso de bajo nivel que libera memoria eliminando objetos que ya no se usan, evitando fugas de memoria.
         4. **Modularidad**: Las aplicaciones grandes se desarrollan a partir de módulos más pequeños, lo que facilita la escritura, mantenimiento y escalabilidad del código.
         5. **Fuertemente tipado**: Cada variable debe tener un tipo de dato definido, lo que garantiza mayor seguridad y control durante la ejecución.
         6. **Desarrollo para múltiples entornos**:
            - Aplicaciones de consola y scripts.
            - Aplicaciones de escritorio con **Swing** y **JavaFX**.
            - Aplicaciones web dinámicas con **Java Enterprise Edition (JEE)**.
            - **APIs REST** para arquitecturas en la nube y microservicios.
            - Frameworks populares como **Spring Boot** para desarrollo empresarial.
      ## Resumen
         Java es un lenguaje versátil y poderoso que ha evolucionado desde sus orígenes para ser uno de los más utilizados en la industria.
         Desde aplicaciones de escritorio hasta sistemas distribuidos y arquitecturas en la nube, Java sigue siendo una opción robusta y
            relevante para desarrolladores en todo el mundo.

      Primer Proyecto
         https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html
         https://www.jetbrains.com/help/idea/new-project-wizard.html
         Configuración inicial y realizar ejercicios.

   2. Variables
      ### **1. Introducción a las variables**
         Una variable es un espacio en memoria donde se almacena un dato que puede cambiar durante la ejecución del programa.
         En Java, todas las variables deben declararse con un tipo específico, lo que garantiza la seguridad del tipo de dato.

      ### **2. Ejemplos de variables**
         - **int**: `int edad = 25;`
         - **double**: `double salario = 45678.90;`
         - **char**: `char inicial = 'A';`
         - **boolean**: `boolean esActivo = true;`

      ### **3. Reglas para definir una variable**
         - Debe comenzar con una letra, `$` o `_`.
         - No puede usar palabras reservadas como `int`, `public`.
         - Es sensible a mayúsculas y minúsculas (`Edad` es diferente de `edad`).
         - No se permiten espacios ni caracteres especiales.

      ### **4. Introducción a los primitivos**
         Java tiene 8 tipos de datos primitivos que almacenan valores simples, como números, caracteres o valores booleanos.
         No son objetos, por lo que tienen mejor rendimiento.

      ### **5. Primitivos numéricos enteros**
         - **byte** (8 bits): Rango: -128 a 127.
         - **short** (16 bits): Rango: -32,768 a 32,767.
         - **int** (32 bits): Rango: -2³¹ a 2³¹ - 1.
         - **long** (64 bits): Rango: -2⁶³ a 2⁶³ - 1.

      ### **6. Primitivos numéricos de punto flotante**
         Se utilizan para almacenar números decimales:
         - **float** (32 bits): Precisión simple.
         - **double** (64 bits): Precisión doble.

      ### **7. Primitivos de punto flotante y sus constantes**
         - **Float.MAX_VALUE**: Máximo valor de `float`.
         - **Double.MAX_VALUE**: Máximo valor de `double`.
         - También existen las constantes `NaN` (Not a Number) y `Infinity`.

      ### **8. Primitivo char o carácter**
         Almacena un único carácter Unicode.

      ### **9. Char y caracteres especiales**
         Caracteres especiales:
         - **'\n'**: Nueva línea
         - **'\t'**: Tabulación
         - **'\\'**: Barra invertida

      ### **10. Primitivo boolean o lógico binario**
         Almacena valores `true` o `false`.

      ### **11. Sistemas numéricos: decimal, binario, octal y hexadecimal**
         - **Decimal**: Base 10 (0-9)
         - **Binario**: Base 2 (0,1)
         - **Octal**: Base 8 (0-7)
         - **Hexadecimal**: Base 16 (0-9, A-F)

      ### **12. Sistemas numéricos y entradas desde ventana de diálogo**
         **Ejemplo:**
         import javax.swing.JOptionPane;
         String input = JOptionPane.showInputDialog("Ingresa un número:");
         int numero = Integer.parseInt(input);

      ### **13. Sistemas numéricos y entradas desde terminal**
         **Ejemplo:**
         import java.util.Scanner;
         Scanner scanner = new Scanner(System.in);
         System.out.print("Ingresa un número: ");
         int numero = scanner.nextInt();

      ### **14. Conversión de cadenas a primitivos**
         Se usa la clase `Wrapper` para convertir:
         - `Integer.parseInt()` para convertir a `int`.
         - `Double.parseDouble()` para convertir a `double`.

      ### **15. Conversiones entre tipos primitivos**
         Java permite conversiones entre tipos primitivos de dos maneras:
         - **Conversión implícita** (automática):
            int num = 10;
            double resultado = num;  // int se convierte en double
         - **Conversión explícita** (casting):
            double valor = 9.7;
            int entero = (int) valor;  // Se pierde la parte decimal

   3. Tipo String: Cadenas
      ### **Clase `String` en Java**
         La clase `String` en Java representa una secuencia de caracteres y es inmutable, lo que significa que una vez creada, no puede cambiar.
         Cualquier operación que modifique una cadena genera un nuevo `String` en memoria.

      #### **Creación de un `String`**
         Hay dos formas principales de crear un `String` en Java:
         1. **Literal**: `"cadena"` — Java almacena las cadenas literales en un "pool de strings" para optimizar la memoria.
            String nombre = "Andrés";

         2. **Usando el operador `new`**: se crea un nuevo objeto `String`, no almacenado en el pool.
            String nombre = new String("Andrés");
            Aunque ambas formas son válidas, se recomienda la primera por su simplicidad y eficiencia.

      #### **Características principales de `String`**
         - **Inmutabilidad**: Al ser inmutables, cualquier operación sobre un `String` (como cambiar su contenido) genera un nuevo objeto `String`.
         - **Secuencia de caracteres**: `String` es una secuencia de caracteres Unicode, lo que permite representar textos en múltiples lenguajes.
         - **No es un tipo primitivo**: Aunque se usa de forma similar a los tipos primitivos, `String` es un objeto.

      #### **Escapar caracteres**
         Para incluir comillas o caracteres especiales dentro de un `String`, se usa el carácter de escape `\`.
         String texto = "Ella dijo, \"Hola\"";

      ### **Métodos principales de la clase `String`**
         #### 1. **Comparación de cadenas**
            - **equals()**: Compara el contenido de dos `String` y retorna `true` si son iguales.
              String s1 = "hola";
              String s2 = new String("hola");
              boolean iguales = s1.equals(s2); // true
            - **equalsIgnoreCase()**: Similar a `equals()`, pero ignora las mayúsculas y minúsculas.
              boolean iguales = s1.equalsIgnoreCase(s2); // true
            - **compareTo()**: Compara lexicográficamente dos cadenas. Devuelve un valor:
              - Negativo si el primero es menor.
              - Cero si son iguales.
              - Positivo si el primero es mayor.
              int resultado = s1.compareTo(s2);

         #### 2. **Manipulación de contenido**
            - **concat()**: Une dos `String`.
               String completo = s1.concat(s2);
            - También se puede usar el operador `+` para concatenar.

            - **substring(int beginIndex, int endIndex)**: Extrae una subcadena desde `beginIndex` hasta `endIndex` (exclusivo).
               String subcadena = s1.substring(1, 3); // "ol"

            - **replace()**: Reemplaza caracteres o cadenas dentro del `String`.
               String nuevaCadena = s1.replace('h', 'j'); // "jola"

         #### 3. **Buscar contenido**
            - **indexOf()**: Encuentra la primera aparición de un carácter o `String`. Retorna `-1` si no encuentra el valor.
               int posicion = s1.indexOf("a"); // 1
            - **lastIndexOf()**: Encuentra la última aparición de un carácter o `String`.
               int ultimaPosicion = s1.lastIndexOf("a");

         #### 4. **Métodos para verificar contenido**
            - **startsWith()** y **endsWith()**: Verifican si un `String` comienza o termina con cierto prefijo o sufijo.
              boolean empiezaCon = s1.startsWith("ho"); // true
              boolean terminaCon = s1.endsWith("la");   // true

         #### 5. **Otras operaciones útiles**
            - **length()**: Devuelve el número de caracteres en el `String`.
               int longitud = s1.length();
            - **isEmpty()**: Retorna `true` si el `String` está vacío (`length() == 0`).
               boolean vacio = s1.isEmpty();
            - **trim()**: Elimina los espacios al inicio y al final de la cadena.
               String sinEspacios = s1.trim();
            - **charAt(int index)**: Obtiene el carácter en una posición específica.
               char c = s1.charAt(1); // 'o'

         #### 6. **Convertir `String` a otros tipos**
            - **toCharArray()**: Convierte el `String` en un arreglo de caracteres.
               char[] caracteres = s1.toCharArray();
            - **split(String regex)**: Divide el `String` en un arreglo de subcadenas según el patrón de regex.
               String[] partes = s1.split(" ");

         #### 7. **Conversiones de mayúsculas y minúsculas**
            - **toUpperCase()**: Convierte todos los caracteres a mayúsculas.
               String enMayusculas = s1.toUpperCase();
            - **toLowerCase()**: Convierte todos los caracteres a minúsculas.
               String enMinusculas = s1.toLowerCase();

         ### **Ejemplo completo usando los métodos principales**
            public class EjemploString {
               public static void main(String[] args) {
                  // Crear strings
                  String saludo = "Hola";
                  String nombre = "Andrés";
                  String completo = saludo + " " + nombre;

                  // Comparación
                  boolean esIgual = saludo.equals("hola"); // false
                  boolean esIgualIgnoreCase = saludo.equalsIgnoreCase("hola"); // true

                  // Longitud y caracter en posición
                  int longitud = completo.length();
                  char primerCaracter = completo.charAt(0); // 'H'

                  // Substring y reemplazo
                  String subcadena = completo.substring(5); // "Andrés"
                  String reemplazo = completo.replace("Hola", "Bienvenido"); // "Bienvenido Andrés"

                  // Transformaciones
                  String enMayusculas = completo.toUpperCase(); // "HOLA ANDRÉS"
                  String enMinusculas = completo.toLowerCase(); // "hola andrés"
                  String sinEspacios = "   espacio   ".trim(); // "espacio"

                  // Dividir y concatenar
                  String[] partes = completo.split(" ");
                  String nombreCompleto = partes[0].concat(" " + partes[1]);

                  // Imprimir resultados
                  System.out.println("Original: " + completo);
                  System.out.println("Es igual (ignore case): " + esIgualIgnoreCase);
                  System.out.println("Longitud: " + longitud);
                  System.out.println("Reemplazo: " + reemplazo);
                  System.out.println("Subcadena: " + subcadena);
                  System.out.println("Mayúsculas: " + enMayusculas);
                  System.out.println("Sin espacios: " + sinEspacios);
               }
            }

   4. Operadores
      Los operadores en Java se utilizan para realizar cálculos matemáticos, evaluar condiciones y manipular datos de manera eficiente.

      ### 1. Operadores Aritméticos
         Estos operadores permiten realizar operaciones matemáticas con tipos de datos numéricos primitivos (`int`, `double`, etc.) y con sus clases envolventes, como `Integer`.
         Los operadores más comunes son:
            - **Suma (+)**: Realiza la adición de valores.
            - **Resta (-)**: Resta un valor de otro.
            - **Multiplicación (*)**: Multiplica valores.
            - **División (/)**: Divide el primer valor entre el segundo.
            - **Módulo (%)**: Devuelve el resto de la división entera.
         También tenemos los operadores de **incremento** (`++`) y **decremento** (`--`), que aumentan o disminuyen el valor de una variable en 1.
            Estos pueden colocarse antes o después de la variable, lo que define si se aplica antes o después de evaluar la expresión.

         #### Autoboxing y Unboxing
         Java permite usar operadores aritméticos con clases envolventes (como `Integer`).
         La conversión entre tipos primitivos y sus clases envolventes ocurre automáticamente, en un proceso llamado **autoboxing** (primitivo a envolvente) y
            **unboxing** (envolvente a primitivo).

      ### 2. Operadores de Asignación y Operadores Combinados
         El operador de asignación (`=`) se utiliza para asignar valores a una variable.
         Existen operadores de asignación combinados que permiten realizar y asignar una operación en una sola línea:
            - **+=**: Suma y asigna el resultado.
            - **-=**: Resta y asigna el resultado.
            - **/=**: Divide y asigna el resultado.
            - **%=**: Aplica módulo y asigna el resultado.
         Por ejemplo, `a += 5;` es equivalente a `a = a + 5;`.

      ### 3. Operadores Incremento y Decremento
         Estos operadores incrementan o decrementan el valor de una variable en 1.
         - **Pre-incremento y pre-decremento** (`++a` y `--a`): Primero se modifica el valor y luego se usa en la expresión.
         - **Post-incremento y post-decremento** (`a++` y `a--`): Primero se usa el valor actual en la expresión y luego se modifica.

      ### 4. Operador Ternario
         El operador ternario `?:` es una forma abreviada de una expresión `if-else` y permite asignar un valor según una condición. Su estructura es:
         Por ejemplo:
            resultado = (condición) ? valor_si_true : valor_si_false;
            int max = (a > b) ? a : b;

      ### 5. Operadores Relacionales
         Los operadores relacionales comparan valores numéricos o variables y devuelven un resultado booleano (`true` o `false`):
            - **==**: Igualdad.
            - **!=**: Desigualdad.
            - **>**: Mayor que.
            - **>=**: Mayor o igual que.
            - **<**: Menor que.
            - **<=**: Menor o igual que.
         Estos operadores se usan en sentencias de control, como `if`, `while`, y `for`.

      ### 6. Operadores Lógicos
         Los operadores lógicos permiten evaluar expresiones booleanas:
         - **&& (AND lógico)**: La expresión es `true` si ambas partes son verdaderas.
         - **|| (OR lógico)**: La expresión es `true` si al menos una de las partes es verdadera.
         - **! (NOT lógico)**: Niega el valor booleano, convirtiendo `true` en `false` y viceversa.

         #### Comparación de Objetos y Primitivos
            Los operadores relacionales (`==`, `!=`) comparan valores en tipos primitivos. En objetos, estos operadores comparan
            referencias (si apuntan al mismo objeto en memoria). Para comparar valores de objetos, se usa el método `.equals()`.

      ### 7. Operadores Bit a Bit
         Los operadores bit a bit (`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`) manipulan los bits individuales en tipos numéricos y se usan
            principalmente en programación de bajo nivel.

      ### 8. Precedencia de Operadores
         La **precedencia** define el orden en que los operadores se evalúan en una expresión. Desde mayor a menor precedencia:
            1. **Paréntesis**: `( )`
            2. **Incremento/Decremento**: `++`, `--` (pre/post)
            3. **Aritméticos**: `*`, `/`, `%`, `+`, `-`
            4. **Relacionales**: `>`, `>=`, `<`, `<=`
            5. **Igualdad/Desigualdad**: `==`, `!=`
            6. **Lógicos**: `&&`, `||`
            7. **Asignación**: `=`, `+=`, `-=`, `*=`, `/=`
         Este orden puede modificarse usando paréntesis para agrupar expresiones y dar prioridad a ciertas operaciones.

   5. Flujos de control
      #### **1. IF (Toma de decisiones basadas en condiciones booleanas)**
         - **Funcionamiento:**
         - Evalúa una expresión booleana entre paréntesis.
         - Si la condición es `true`, ejecuta un bloque de código.
            Por ejemplo:
               int edad = 18;
               if (edad >= 18) {
                  System.out.println("Eres mayor de edad.");
               } else {
                  System.out.println("Eres menor de edad.");
               }
            - Si es `false`, puede ejecutarse un bloque alternativo usando `else`.
            Por ejemplo:
               int nota = 85;
               if (nota >= 90) {
                  System.out.println("Sobresaliente");
               } else if (nota >= 70) {
                  System.out.println("Aprobado");
               } else {
                  System.out.println("Reprobado");
               }

         - **Buena práctica:**
            - Siempre usar llaves `{}` para definir los bloques de código, aunque contengan una sola línea. Esto mejora la claridad y evita errores.

         - **Estructura:**
            - Se pueden encadenar múltiples condiciones usando `else if`.
            - Se puede añadir un `else` al final como camino alternativo en caso de que ninguna condición se cumpla.

         - **Llaves opcionales:**
            - Si el bloque contiene una sola línea, las llaves son opcionales, pero no recomendado omitirlas.

      #### **2. SWITCH (Selección por valor)**
         - **Funcionamiento:**
         - Evalúa una variable y la compara con varios casos (`case`).
         - Cuando encuentra coincidencia, ejecuta el bloque asociado.
         - Útil para decisiones basadas en valores constantes.
         Por ejemplo:
            int dia = 3;
            switch (dia) {
            case 1:
               System.out.println("Lunes");
               break;
            case 2:
               System.out.println("Martes");
               break;
            case 3:
               System.out.println("Miércoles");
               break;
            default:
               System.out.println("Día no válido");
               break;
            }

         - **Tipos soportados en la expresión:**
            - Primitivos: `int`, `byte`, `short`, `char`.
            - `String` (a partir de JDK 7).
            - Tipos complejos como `enum`.

         - **Buena práctica:**
            - Usar la palabra clave `break` para salir del `switch` después de ejecutar un caso y evitar ejecutar casos posteriores (fallthrough).
            - Se puede incluir un caso `default` para manejar valores no especificados.

      #### **3. Uso de Puntos y Comas (;)**
         - **Separación de sentencias:**
         - Cada línea de código termina con un punto y coma `;`.
         - Útil para encadenar múltiples sentencias en un bucle o una misma línea.

      #### **4. FOR (Bucle de control iterativo)**
         - **Estructura:**
            - Tres partes principales:
               1. **Inicialización:** Define una variable de control (contador).
               2. **Condición:** Evalúa si el bucle debe continuar.
               3. **Incremento:** Modifica la variable de control tras cada iteración.
               Por ejemplo for simple:
                  for (int i = 1; i <= 5; i++) {
                     System.out.println("Número: " + i);
                  }
               Por ejemplo for con matrices:
                  for (int i = 0; i < 3; i++) {
                      for (int j = 0; j < 3; j++) {
                          System.out.print("(" + i + "," + j + ") ");
                      }
                      System.out.println(); // Salto de línea
                  }

      #### **5. Otros conceptos útiles:**
         - **Comas (,):**
            - Separan identificadores al declarar múltiples variables.
            - Separan argumentos o parámetros en métodos.
         - **Puntos (.):**
            - Usados con objetos para acceder a métodos o atributos.
            - Separan nombres de paquetes y clases (e.g., `java.util.Scanner`).
            - Acceden a métodos o atributos estáticos (e.g., `Math.PI`).

   6. Clases Wrapper
      Objetos que "envuelven" (wrap) a los tipos de datos primitivos, permitiéndoles ser tratados como objetos.
      Son útiles para:
      Trabajar con colecciones (List, Set, etc.), ya que estas requieren objetos.
      Usar métodos de utilidad para conversión y comprobación.
      Manejar constantes como MIN_VALUE y MAX_VALUE.

      #### **Lista de Clases Wrapper
         Java proporciona una clase wrapper para cada tipo de dato primitivo:
         Primitivo	Clase Wrapper
         byte     	Byte
         short    	Short
         int      	Integer
         long     	Long
         float    	Float
         double      Double
         char     	Character
         boolean     Boolean

      #### **La Clase Byte
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo byte tiene la clase Byte.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Byte.
            Byte b = Byte.valueOf((byte) 127);
            String s = b.toString();
            byte primByte = b.byteValue();
            short sh = b.shortValue();
            int i = b.intValue();
            long l = b.longValue();
            float f = b.floatValue();
            double d = b.doubleValue();
            byte parsed = Byte.parseByte("127");

         - **Constantes de Byte
            Byte.MIN_VALUE
            Byte.MAX_VALUE

         - **Métodos estáticos
            String Byte.toString(byte b)
            byte Byte.parseByte(String s)
            byte Byte.parseByte(String s, int base)
            Byte Byte.valueOf(String s)
            Byte Byte.valueOf(byte b)

         - **Métodos de la instancia
            byte byteValue()
            short shortValue()
            int intValue()
            long longValue()
            float floatValue()
            double doubleValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Short
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo short tiene la clase Short.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Short.
            Short sh = Short.valueOf((short) 32767);
            String s = sh.toString();
            short primShort = sh.shortValue();
            int i = sh.intValue();
            long l = sh.longValue();
            float f = sh.floatValue();
            double d = sh.doubleValue();
            short parsed = Short.parseShort("32767");

         - **Constantes de Short
            Short.MIN_VALUE
            Short.MAX_VALUE

         - **Métodos estáticos
            String Short.toString(short s)
            short Short.parseShort(String s)
            short Short.parseShort(String s, int base)
            Short Short.valueOf(String s)
            Short Short.valueOf(short s)

         - **Métodos de la instancia
            short shortValue()
            int intValue()
            long longValue()
            float floatValue()
            double doubleValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Integer
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo int tiene la clase Integer.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Integer.
            Integer i = Integer.valueOf(1234567);
            String s = i.toString();
            int primInt = i.intValue();
            long l = i.longValue();
            float f = i.floatValue();
            double d = i.doubleValue();
            int parsed = Integer.parseInt("2147483647");

         - **Constantes de Integer
            Integer.MIN_VALUE
            Integer.MAX_VALUE

         - **Métodos estáticos
            String Integer.toString(int i, int base)
            String Integer.toString(int i)
            int Integer.parseInt(String s, int base)
            int Integer.parseInt(String s)
            Integer Integer.valueOf(String s, int base)
            Integer Integer.valueOf(String s)

         - **Métodos de la instancia
            int intValue()
            long longValue()
            float floatValue()
            double doubleValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)
            byte byteValue()
            short shortValue()

      #### **La Clase Long
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo long tiene la clase Long.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Long.
            Long l = Long.valueOf(9223372036854775807L);
            String s = l.toString();
            long primLong = l.longValue();
            int i = l.intValue();
            float f = l.floatValue();
            double d = l.doubleValue();
            long parsed = Long.parseLong("9223372036854775807");

         - **Constantes de Long
            Long.MIN_VALUE
            Long.MAX_VALUE

         - **Métodos estáticos
            String Long.toString(long l)
            long Long.parseLong(String s)
            long Long.parseLong(String s, int base)
            Long Long.valueOf(String s)
            Long Long.valueOf(long l)

         - **Métodos de la instancia
            long longValue()
            int intValue()
            float floatValue()
            double doubleValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Float
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo float tiene la clase Float.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Float.
            Float f = Float.valueOf(3.14f);
            String s = f.toString();
            float primFloat = f.floatValue();
            int i = f.intValue();
            long l = f.longValue();
            double d = f.doubleValue();
            float parsed = Float.parseFloat("3.14");

         - **Constantes de Float
            Float.MIN_VALUE
            Float.MAX_VALUE
            Float.NaN
            Float.POSITIVE_INFINITY
            Float.NEGATIVE_INFINITY

         - **Métodos estáticos
            String Float.toString(float f)
            float Float.parseFloat(String s)
            Float Float.valueOf(String s)
            Float Float.valueOf(float f)

         - **Métodos de la instancia
            float floatValue()
            int intValue()
            long longValue()
            double doubleValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Double
         Cada tipo numérico tiene su propia clase de objetos.
         Así, el tipo double tiene la clase Double.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Double.
            Double d = Double.valueOf(3.141592653589793);
            String s = d.toString();
            double primDouble = d.doubleValue();
            int i = d.intValue();
            long l = d.longValue();
            float f = d.floatValue();
            double parsed = Double.parseDouble("3.141592653589793");

         - **Constantes de Double
            Double.MIN_VALUE
            Double.MAX_VALUE
            Double.NaN
            Double.POSITIVE_INFINITY
            Double.NEGATIVE_INFINITY

         - **Métodos estáticos
            String Double.toString(double d)
            double Double.parseDouble(String s)
            Double Double.valueOf(String s)
            Double Double.valueOf(double d)

         - **Métodos de la instancia
            double doubleValue()
            int intValue()
            long longValue()
            float floatValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Character
         Cada tipo de carácter tiene su propia clase de objetos.
         Así, el tipo char tiene la clase Character.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Character.
            Character c = Character.valueOf('A');
            String s = c.toString();
            char primChar = c.charValue();
            boolean isLetter = Character.isLetter(c);
            boolean isDigit = Character.isDigit(c);

         - **Constantes de Character
            Character.MIN_VALUE
            Character.MAX_VALUE

         - **Métodos estáticos
            boolean Character.isLetter(char c)
            boolean Character.isDigit(char c)
            boolean Character.isUpperCase(char c)
            boolean Character.isLowerCase(char c)
            boolean Character.isWhitespace(char c)
            Character toUpperCase(char c)
            Character toLowerCase(char c)
            String Character.toString(char c)
            Character Character.valueOf(char c)

         - **Métodos de la instancia
            char charValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

      #### **La Clase Boolean
         Cada tipo booleano tiene su propia clase de objetos.
         Así, el tipo boolean tiene la clase Boolean.
         - **Se implementan varios métodos útiles dentro de la clase envoltorio Boolean.
            Boolean b = Boolean.valueOf(true);
            String s = b.toString();
            boolean primBoolean = b.booleanValue();
            boolean parsed = Boolean.parseBoolean("true");

         - **Constantes de Boolean
            Boolean.TRUE
            Boolean.FALSE

         - **Métodos estáticos
            String Boolean.toString(boolean b)
            boolean Boolean.parseBoolean(String s)
            Boolean Boolean.valueOf(String s)
            Boolean Boolean.valueOf(boolean b)

         - **Métodos de la instancia
            boolean booleanValue()
            String toString()
            int hashCode()
            boolean equals(Object obj)

   7. Valor v/S referencia
      En Java, el concepto de "valor" y "referencia" se refiere a cómo se pasan los argumentos a los métodos y cómo se manejan los datos en memoria.

      1. **Por Valor**:
         Java siempre pasa los **argumentos por valor**, es decir, pasa una copia del valor.
         - Si el argumento es un tipo **primitivo** (como `int`, `char`, `float`, etc.), se pasa el **valor** del dato.
         - Si el argumento es un tipo **objeto** (como una instancia de una clase), se pasa la **referencia**
            (dirección de memoria) al objeto, pero **no** el objeto en sí.

      2. **Por Referencia**:
         Aunque en Java no se puede pasar por referencia en el sentido clásico como en otros lenguajes como C++ (donde las direcciones
            de memoria de los objetos pueden ser manipuladas directamente), se simula el paso por referencia al pasar **referencias** de objetos.
         Sin embargo, es importante recordar que **Java sigue pasando siempre los parámetros por valor**. Lo que cambia es lo que se pasa:
            el valor de una variable primitiva o la referencia a un objeto.

      ### **Pasar Argumento por Valor**
         En Java, cuando pasamos un argumento por valor, estamos pasando **una copia** del valor de la variable original.
         Esto es aplicable cuando se pasan **tipos primitivos** como `int`, `float`, `char`, etc.

         Ejemplo:
            public class PassByValueExample {
                public static void main(String[] args) {
                    int x = 10;
                    changeValue(x);
                    System.out.println("Valor de x después del método: " + x); // x sigue siendo 10
                }

                public static void changeValue(int value) {
                    value = 20;  // solo cambia la copia local de 'value', no 'x'
                }
            }

         **Explicación**:
            - `x` se pasa por valor al método `changeValue`, lo que significa que la copia de `x` (llamada `value`) es modificada dentro del método.
            - El valor original de `x` no se ve afectado fuera del método porque el argumento `x` fue copiado, no referenciado.

      ### **Pasar Argumento por Referencia**
         Cuando pasamos un argumento por **referencia**, se está pasando una referencia al objeto en memoria, no una copia.
         Esto es relevante solo para los **objetos** (instancias de clases).
         Ejemplo:
         public class PassByReferenceExample {
             public static void main(String[] args) {
                 Persona p = new Persona("Rafa");
                 System.out.println("Antes del cambio: " + p.getNombre());
                 changeName(p);
                 System.out.println("Después del cambio: " + p.getNombre()); // El nombre cambia a 'Juan'
             }

             public static void changeName(Persona persona) {
                 persona.setNombre("Juan");  // Se modifica el objeto original
             }
         }

         class Persona {
             private String nombre;

             public Persona(String nombre) {
                 this.nombre = nombre;
             }

             public String getNombre() {
                 return nombre;
             }

             public void setNombre(String nombre) {
                 this.nombre = nombre;
             }
         }

         **Explicación**:
            - En este caso, `p` es un objeto de tipo `Persona` que se pasa al método `changeName` por referencia.
            - **La referencia** al objeto `p` es pasada al método, lo que significa que cualquier cambio hecho en el objeto
               dentro del método afecta al objeto original.
            - Aunque **Java pasa siempre por valor** (la referencia es pasada por valor), al ser un objeto, lo que se pasa es
               la dirección de memoria, lo que permite modificar los atributos del objeto original.

      ### **Pasar Argumento por Referencia con un Objeto Persona**
         Esto es lo que ocurre cuando se pasa un objeto como argumento.
         Imagina que tienes una clase `Persona` y deseas cambiar sus atributos dentro de un método. Cuando se pasa el objeto a ese método,
         estás pasando una **referencia** al objeto en memoria, lo que permite modificar sus campos.
         Ejemplo:
         public class TestReferencePassing {
             public static void main(String[] args) {
                 Persona persona = new Persona("Rafa");
                 System.out.println("Antes: " + persona.getNombre()); // Rafa
                 changeName(persona);
                 System.out.println("Después: " + persona.getNombre()); // Juan
             }

             public static void changeName(Persona p) {
                 p.setNombre("Juan");  // Cambia el valor del nombre de la persona
             }
         }

         class Persona {
             private String nombre;

             public Persona(String nombre) {
                 this.nombre = nombre;
             }

             public String getNombre() {
                 return nombre;
             }

             public void setNombre(String nombre) {
                 this.nombre = nombre;
             }
         }

         **Explicación**:
            - Cuando se pasa el objeto `persona` a la función `changeName`, lo que realmente se pasa es la **referencia** al objeto, no una copia.
            - Por lo tanto, cualquier cambio en el objeto dentro del método afecta directamente al objeto original.

         Aunque es importante recordar que **Java no pasa por referencia en el sentido clásico** (como C++), cuando trabajas con objetos,
         parece que el paso es por referencia porque los métodos pueden modificar el objeto directamente.

      ### Resumen de Diferencias entre Valor y Referencia en Java
         - **Por Valor (tipos primitivos)**: Se pasa una copia del valor de la variable. Los cambios dentro del método no afectan el valor original.
         - **Por Referencia (objetos)**: Se pasa la referencia (dirección en memoria) del objeto. Los cambios realizados dentro
            del método afectan al objeto original.

   8. Las clases Date y Calendar

      ## La Clase `Date`
         - La clase `Date` pertenece al paquete `java.util` y se utiliza para trabajar con fechas y horas.
         - Representa un instante en el tiempo, especificado como milisegundos desde la **"Época Unix"** (1 de enero de 1970, 00:00:00 GMT).

         ### Métodos principales:
            - `long getTime()`: Devuelve el tiempo en milisegundos desde el 1 de enero de 1970.
            - `boolean before(Date when)`: Verifica si esta fecha es anterior a la fecha especificada.
            - `boolean after(Date when)`: Verifica si esta fecha es posterior a la fecha especificada.
            - `boolean equals(Object obj)`: Compara si dos objetos `Date` representan el mismo instante.
            ### Ejemplo básico:
               import java.util.Date;
               public class EjemploDate {
                   public static void main(String[] args) {
                       Date ahora = new Date();
                       System.out.println("Fecha y hora actual: " + ahora);

                       long milisegundos = ahora.getTime();
                       System.out.println("Tiempo en milisegundos desde 1970: " + milisegundos);
                   }
               }

      ## La Clase `Calendar`
         - La clase `Calendar` es más flexible que `Date` y permite manipular fácilmente componentes individuales de una fecha (día, mes, año, etc.).
         - Es una clase abstracta y se obtiene una instancia utilizando el método estático `Calendar.getInstance()`.

         ### Métodos principales:
            - `void set(int field, int value)`: Establece un valor para un campo específico (e.g., `Calendar.YEAR`, `Calendar.MONTH`).
            - `int get(int field)`: Obtiene el valor de un campo específico.
            - `Date getTime()`: Convierte el objeto `Calendar` a un objeto `Date`.
            - `void add(int field, int amount)`: Agrega (o resta) una cantidad a un campo específico.
            ### Ejemplo básico:
               import java.util.Calendar;
               public class EjemploCalendar {
                   public static void main(String[] args) {
                       Calendar calendario = Calendar.getInstance();
                       System.out.println("Fecha y hora actual: " + calendario.getTime());

                       // Modificar la fecha
                       calendario.set(Calendar.YEAR, 2025);
                       System.out.println("Fecha modificada: " + calendario.getTime());
                   }
               }

      ## Formatos de Fecha
         - La clase `SimpleDateFormat` permite formatear y analizar fechas.
         - Formatos comunes:
           - `"dd/MM/yyyy"`: Día/Mes/Año.
           - `"yyyy-MM-dd"`: Año-Mes-Día.
           - `"HH:mm:ss"`: Hora, minutos, segundos.
         ### Ejemplo:
            import java.text.SimpleDateFormat;
            import java.util.Date;
            public class EjemploFormatoFecha {
                public static void main(String[] args) {
                    Date ahora = new Date();
                    SimpleDateFormat formato = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
                    System.out.println("Fecha y hora formateada: " + formato.format(ahora));
                }
            }

      ## Convertir una Cadena (`String`) a un Objeto `Date`
         - Usa `SimpleDateFormat` con el método `parse(String source)`.
         ### Ejemplo:
            import java.text.SimpleDateFormat;
            import java.util.Date;
            public class EjemploStringADate {
                public static void main(String[] args) throws Exception {
                    String fechaStr = "15/12/2024";
                    SimpleDateFormat formato = new SimpleDateFormat("dd/MM/yyyy");
                    Date fecha = formato.parse(fechaStr);

                    System.out.println("Fecha convertida: " + fecha);
                }
            }

      ## Comparar Fechas
         - Usa los métodos `before()`, `after()` o `compareTo()`.
         ### Ejemplo:
            import java.util.Date;
            public class EjemploCompararFechas {
                public static void main(String[] args) {
                    Date fecha1 = new Date();
                    Date fecha2 = new Date(fecha1.getTime() + 100000); // Suma 100,000 ms

                    System.out.println("Fecha 1: " + fecha1);
                    System.out.println("Fecha 2: " + fecha2);

                    if (fecha1.before(fecha2)) {
                        System.out.println("Fecha 1 es antes que Fecha 2.");
                    } else if (fecha1.after(fecha2)) {
                        System.out.println("Fecha 1 es después que Fecha 2.");
                    } else {
                        System.out.println("Ambas fechas son iguales.");
                    }
                }
            }

      ## Información adicional
         - Las clases `Date` y `Calendar` son consideradas algo antiguas y limitadas.
            Desde Java 8, es preferible usar las clases del paquete `java.time`, como `LocalDate`, `LocalTime` y `LocalDateTime`.
         - Ejemplo básico con `LocalDate` (reemplazo moderno):
         ###Ejemplo
           import java.time.LocalDate;
           import java.time.format.DateTimeFormatter;
           public class EjemploLocalDate {
              public static void main(String[] args) {
              LocalDate fecha = LocalDate.now();
              System.out.println("Fecha actual: " + fecha);

              // Formatear fecha
              DateTimeFormatter formato = DateTimeFormatter.ofPattern("dd/MM/yyyy");
              System.out.println("Fecha formateada: " + fecha.format(formato));
              }
           }

   9. Clase System
      - La clase `System` pertenece al paquete `java.lang` y ofrece acceso a funcionalidades generales del sistema.
      - Contiene métodos y propiedades estáticas que permiten interactuar con el sistema operativo.

      ### **Obtener propiedades del sistema**
         - Usa el método `System.getProperty(String key)` para obtener propiedades específicas del sistema.
         - Puedes obtener información como:
           - `os.name`: Nombre del sistema operativo.
           - `java.version`: Versión de Java.
           - `user.home`: Directorio principal del usuario.

         #### **Ejemplo**:
         public class PropiedadesSistema {
             public static void main(String[] args) {
                 System.out.println("Sistema Operativo: " + System.getProperty("os.name"));
                 System.out.println("Versión de Java: " + System.getProperty("java.version"));
                 System.out.println("Carpeta del usuario: " + System.getProperty("user.home"));
             }
         }

      ### **Agregar y personalizar propiedades de la aplicación**
         - Usa `System.setProperty(String key, String value)` para agregar o modificar propiedades personalizadas.

         #### **Ejemplo**:
         public class PropiedadesPersonalizadas {
             public static void main(String[] args) {
                 System.setProperty("miApp.version", "1.0");
                 System.setProperty("miApp.nombre", "TocayoApp");

                 System.out.println("Versión de la aplicación: " + System.getProperty("miApp.version"));
                 System.out.println("Nombre de la aplicación: " + System.getProperty("miApp.nombre"));
             }
         }

      ### **Obtener las variables de ambiente del sistema operativo**
         - Usa `System.getenv(String name)` para obtener una variable específica.
         - Usa `System.getenv()` para obtener todas las variables en un `Map`.

         #### **Ejemplo**:
         import java.util.Map;
         public class VariablesAmbiente {
             public static void main(String[] args) {
                 // Obtener una variable específica
                 System.out.println("Variable PATH: " + System.getenv("PATH"));

                 // Obtener todas las variables
                 Map<String, String> env = System.getenv();
                 env.forEach((key, value) -> System.out.println(key + ": " + value));
             }
         }

      ### **Otras características y funciones útiles de la clase `System`**
         - **Impresión estándar y errores**:
           - `System.out`: Flujo estándar para imprimir en consola.
           - `System.err`: Flujo para mensajes de error.
         - **Finalizar un programa**:
           - Usa `System.exit(int status)` para finalizar un programa con un estado específico.
             - `0`: Indica finalización exitosa.
             - Valores diferentes de `0`: Indican errores.

         #### **Ejemplo**:
         public class FinalizarPrograma {
             public static void main(String[] args) {
                 System.out.println("Mensaje normal");
                 System.err.println("Mensaje de error");
                 System.exit(0); // Finaliza con éxito
             }
         }

      ## **Clase `Runtime`**
         - La clase `Runtime` representa el entorno en el que se ejecuta el programa Java.
         - Usa `Runtime.getRuntime()` para obtener una instancia.

      ### **Ejecutar aplicaciones del sistema operativo**
         - Usa `Runtime.exec(String command)` para ejecutar un comando del sistema operativo.

         #### **Ejemplo**:
         import java.io.IOException;
         public class EjecutarComando {
             public static void main(String[] args) {
                 try {
                     Runtime.getRuntime().exec("notepad.exe"); // Abre el Bloc de notas en Windows
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
             }
         }

      ### **Administrar memoria**
         - Métodos importantes:
           - `long totalMemory()`: Total de memoria asignada al programa.
           - `long freeMemory()`: Memoria disponible.
           - `void gc()`: Solicita al recolector de basura liberar memoria.

         #### **Ejemplo**:
         public class AdministrarMemoria {
             public static void main(String[] args) {
                 Runtime runtime = Runtime.getRuntime();

                 System.out.println("Memoria total: " + runtime.totalMemory());
                 System.out.println("Memoria libre antes: " + runtime.freeMemory());

                 // Simular carga de memoria
                 int[] arreglo = new int[100000];
                 System.out.println("Memoria libre después: " + runtime.freeMemory());

                 // Solicitar recolector de basura
                 runtime.gc();
                 System.out.println("Memoria libre tras GC: " + runtime.freeMemory());
             }
         }

      ### **Cerrar la máquina virtual (JVM)**
         - Puedes usar `addShutdownHook` para ejecutar tareas antes de que la JVM termine.
         #### **Ejemplo**:
         public class CerrarJVM {
             public static void main(String[] args) {
                 Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                     System.out.println("¡La JVM se está cerrando!");
                 }));

                 System.out.println("Finalizando programa...");
                 System.exit(0);
             }
         }

      ## **Información adicional**
         - **Alternativas modernas**:
           - Desde Java 8, para manejar fechas y tiempos de manera más robusta, se recomienda el paquete `java.time` (e.g., `Instant`, `LocalDateTime`).
         - **Precaución al ejecutar comandos del sistema operativo**:
           - El uso de `Runtime.exec()` es dependiente del sistema operativo. Para soluciones más avanzadas, usa `ProcessBuilder`.

   10. La Clase Math
      1. **Clase final**: No puede ser extendida.
      2. **Métodos estáticos**: Todos los métodos son estáticos, por lo que no necesitas instanciar la clase.
      3. **Constantes predefinidas**:
         - `Math.PI`: Representa el valor de π (3.14159...).
         - `Math.E`: Representa el valor de *e* (2.71828...).

      ## **Funciones matemáticas básicas**
         ### **Operaciones comunes**
         int abs = Math.abs(-10);       // Valor absoluto: 10
         double ceil = Math.ceil(2.3);  // Redondeo hacia arriba: 3.0
         double floor = Math.floor(2.7); // Redondeo hacia abajo: 2.0
         double round = Math.round(2.5); // Redondeo al número entero más cercano: 3
         double max = Math.max(10, 20);  // Máximo: 20
         double min = Math.min(10, 20);  // Mínimo: 10

         ### **Potencias y raíces**
         double pow = Math.pow(2, 3);  // Potencia: 2^3 = 8.0
         double sqrt = Math.sqrt(16);  // Raíz cuadrada: 4.0
         double cbrt = Math.cbrt(27);  // Raíz cúbica: 3.0

         ### **Logaritmos y exponenciales**
         double exp = Math.exp(2);     // e^2: 7.389056...
         double log = Math.log(10);    // Logaritmo natural (base e): 2.302585...
         double log10 = Math.log10(100); // Logaritmo en base 10: 2.0

      ## **Trigonometría**
         ### **Funciones trigonométricas**
         double sin = Math.sin(Math.PI / 2); // Seno: 1.0
         double cos = Math.cos(Math.PI);    // Coseno: -1.0
         double tan = Math.tan(Math.PI / 4); // Tangente: 1.0
         ### **Funciones trigonométricas inversas**
         double asin = Math.asin(1);   // Arco seno: π/2
         double acos = Math.acos(0);   // Arco coseno: π/2
         double atan = Math.atan(1);   // Arco tangente: π/4

      ## **Operaciones aleatorias**
         - Usa `Math.random()` para generar un número aleatorio entre 0 (inclusive) y 1 (exclusivo).
         - Para obtener un rango específico:
           int randomNum = (int)(Math.random() * (max - min + 1)) + min;

         #### **Ejemplo**:
         public class RandomExample {
             public static void main(String[] args) {
                 int min = 1, max = 10;
                 int randomNum = (int) (Math.random() * (max - min + 1)) + min;
                 System.out.println("Número aleatorio: " + randomNum);
             }
         }

      ## **Otras funciones útiles**
         ### **Signo y manipulación**
         int sign = Math.signum(-5);    // Signo: -1 (positivo 1, negativo -1, cero 0)
         double scalb = Math.scalb(1.5, 2); // Escalar: 1.5 * 2^2 = 6.0

         ### **Funciones hiperbólicas**
         double sinh = Math.sinh(1);    // Seno hiperbólico
         double cosh = Math.cosh(1);    // Coseno hiperbólico
         double tanh = Math.tanh(1);    // Tangente hiperbólica

            ## **Ejemplo práctico**
            ### **Cálculo del área de un círculo con `Math`**
            public class AreaCirculo {
                public static void main(String[] args) {
                    double radio = 5;
                    double area = Math.PI * Math.pow(radio, 2);
                    System.out.println("Área del círculo: " + area);
                }
            }

      ## **Consejos y particularidades**
      1. **Rendimiento**: Los métodos de la clase `Math` son rápidos porque están implementados con optimizaciones específicas para cada plataforma.
      2. **Redondeos**: Usa `Math.round()` para redondear a enteros y `Math.floor()` o `Math.ceil()` para ajustes específicos.
      3. **Precisión en trigonometría**: Asegúrate de trabajar en radianes, ya que las funciones trigonométricas de `Math` no aceptan grados. Si trabajas en grados, convierte usando:
         Ejemplo
         double radianes = Math.toRadians(grados);
         double grados = Math.toDegrees(radianes);

   11. Linea de comando

      ### **Línea de comando: Compilar y ejecutar con argumentos**
      En Java, puedes usar la línea de comandos para compilar y ejecutar programas.
      Para pasar argumentos al programa, se utilizan parámetros que llegan como un arreglo de `String` en el método `main`.

      #### **Pasos básicos:**
         1. **Compilar el programa:**
            javac MiPrograma.java
         2. **Ejecutar el programa con argumentos:**
            java MiPrograma arg1 arg2 arg3

         #### **Ejemplo:**
            public class MiPrograma {
                public static void main(String[] args) {
                    System.out.println("Número de argumentos: " + args.length);
                    for (int i = 0; i < args.length; i++) {
                        System.out.println("Argumento " + i + ": " + args[i]);
                    }
                }
            }

            **Ejecutar:**
            java MiPrograma Hola Mundo 123

            **Salida:**
            Número de argumentos: 3
            Argumento 0: Hola
            Argumento 1: Mundo
            Argumento 2: 123

      ### **Línea de comando: Ejemplo de calculadora**
         Puedes crear una calculadora básica que reciba operaciones y números como argumentos.

         #### **Código de ejemplo:**
         public class Calculadora {
             public static void main(String[] args) {
                 if (args.length != 3) {
                     System.out.println("Uso: java Calculadora num1 operador num2");
                     return;
                 }
                 double num1 = Double.parseDouble(args[0]);
                 String operador = args[1];
                 double num2 = Double.parseDouble(args[2]);
                 double resultado = 0;
                 switch (operador) {
                     case "+":
                         resultado = num1 + num2;
                         break;
                     case "-":
                         resultado = num1 - num2;
                         break;
                     case "*":
                         resultado = num1 * num2;
                         break;
                     case "/":
                         if (num2 != 0) {
                             resultado = num1 / num2;
                         } else {
                             System.out.println("Error: División entre cero.");
                             return;
                         }
                         break;
                     default:
                         System.out.println("Operador no válido. Usa +, -, *, o /.");
                         return;
                 }
                 System.out.println("Resultado: " + resultado);
             }
         }

         #### **Ejecutar:**
         java Calculadora 10 + 5

         **Salida:**
         Resultado: 15.0

   12. Arreglos
      Un **arreglo** es una estructura de datos que permite almacenar múltiples elementos del mismo tipo en un bloque contiguo de memoria.
      - Cada elemento del arreglo se accede mediante un índice (comienza en 0).
      - Los arreglos son de tamaño fijo, es decir, una vez creados, no pueden cambiar su longitud.

      ### **Declaración e instanciación de un arreglo**
      En Java, un arreglo debe declararse y luego instanciarse con un tamaño fijo.
      **Sintaxis básica**:
         tipo[] nombreArreglo; // Declaración
         nombreArreglo = new tipo[tamaño]; // Instanciación
         **Ejemplo**:
            int[] numeros;        // Declaración
            numeros = new int[5]; // Instanciación con tamaño 5

         También puedes combinar ambos pasos:
         int[] numeros = new int[5];

      ### **Inicialización de elementos en un arreglo**
      Puedes inicializar elementos en un arreglo uno por uno asignándoles un valor usando su índice:
      numeros[0] = 10; // Primer elemento
      numeros[1] = 20; // Segundo elemento

      Si no inicializas un arreglo explícitamente, Java asignará valores predeterminados:
      - Números: `0`
      - `boolean`: `false`
      - Referencias (objetos): `null`

      ### **Obtener elementos de un arreglo**
      Para acceder a un elemento, usa su índice:
         System.out.println(numeros[0]); // Imprime el primer elemento

      El índice debe estar dentro del rango válido, de lo contrario, arrojará una excepción `ArrayIndexOutOfBoundsException`.

      ### **Declaración, instanciación e inicialización de un arreglo**
      Puedes declarar, instanciar e inicializar un arreglo en una sola línea:
         int[] numeros = {10, 20, 30, 40, 50};

      Esto crea un arreglo de tamaño 5 y asigna valores a sus elementos.

      ### **Recorrer un arreglo usando `for`**
      Un bucle `for` se utiliza para iterar por los índices de un arreglo:
         for (int i = 0; i < numeros.length; i++) {
             System.out.println("Elemento en índice " + i + ": " + numeros[i]);
         }
      La propiedad `length` devuelve el tamaño del arreglo.

      ### **Recorrer un arreglo usando `for-each`**
      El bucle `for-each` es una forma más sencilla de recorrer arreglos, ya que no necesitas manejar índices directamente:
         for (int numero : numeros) {
             System.out.println("Elemento: " + numero);
         }
      **Nota**: El bucle `for-each` es útil para leer elementos, pero no puedes modificar directamente los valores del arreglo.

      ### **Información adicional**
      1. **Arreglos multidimensionales**:
         En Java, puedes crear arreglos con más de una dimensión:
            int[][] matriz = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
            };
            System.out.println(matriz[1][2]); // Imprime 6 (fila 2, columna 3)

      2. **Clase `Arrays`**:
         La clase `java.util.Arrays` proporciona métodos útiles para trabajar con arreglos,
            como ordenar (`sort`), buscar (`binarySearch`) y convertir a cadena (`toString`).

      Ejemplos

      ### **1. Arreglo de enteros**
         int[] numeros = {10, 20, 30, 40, 50};
         System.out.println(numeros[2]); // Imprime 30

      ### **2. Arreglo de strings y ordenar con `sort`**
         String[] frutas = {"Manzana", "Banana", "Cereza", "Durazno"};
         Arrays.sort(frutas); // Ordena alfabéticamente
         System.out.println(Arrays.toString(frutas)); // Imprime [Banana, Cereza, Durazno, Manzana]

      ### **3. Iterando arreglos**
         int[] numeros = {1, 2, 3, 4, 5};
         for (int num : numeros) {
             System.out.println(num); // Imprime cada número
         }

      ### **4. Iterando en orden inverso un arreglo**
         int[] numeros = {10, 20, 30, 40, 50};
         for (int i = numeros.length - 1; i >= 0; i--) {
             System.out.println(numeros[i]);
         }

      ### **5. Modificando el arreglo en reverso**
         int[] numeros = {10, 20, 30, 40, 50};
         for (int i = 0; i < numeros.length / 2; i++) {
             int temp = numeros[i];
             numeros[i] = numeros[numeros.length - 1 - i];
             numeros[numeros.length - 1 - i] = temp;
         }
         System.out.println(Arrays.toString(numeros)); // Imprime [50, 40, 30, 20, 10]

      ### **6. Ordenamiento algoritmo de burbuja**
         int[] numeros = {5, 2, 9, 1, 6};
         for (int i = 0; i < numeros.length - 1; i++) {
             for (int j = 0; j < numeros.length - 1 - i; j++) {
                 if (numeros[j] > numeros[j + 1]) {
                     int temp = numeros[j];
                     numeros[j] = numeros[j + 1];
                     numeros[j + 1] = temp;
                 }
             }
         }
         System.out.println(Arrays.toString(numeros)); // Imprime [1, 2, 5, 6, 9]

      ### **7. Ordenamiento algoritmo burbuja método optimizado**
         int[] numeros = {5, 2, 9, 1, 6};
         boolean swapped;
         for (int i = 0; i < numeros.length - 1; i++) {
             swapped = false;
             for (int j = 0; j < numeros.length - 1 - i; j++) {
                 if (numeros[j] > numeros[j + 1]) {
                     int temp = numeros[j];
                     numeros[j] = numeros[j + 1];
                     numeros[j + 1] = temp;
                     swapped = true;
                 }
             }
             if (!swapped) break; // Sale si ya está ordenado
         }
         System.out.println(Arrays.toString(numeros));

      ### **8. Reutilizando algoritmo burbuja**
         int[] numeros = {4, 3, 2, 1};
         ordenarBurbuja(numeros);
         System.out.println(Arrays.toString(numeros));

         void ordenarBurbuja(int[] arreglo) {
             for (int i = 0; i < arreglo.length - 1; i++) {
                 for (int j = 0; j < arreglo.length - 1 - i; j++) {
                     if (arreglo[j] > arreglo[j + 1]) {
                         int temp = arreglo[j];
                         arreglo[j] = arreglo[j + 1];
                         arreglo[j + 1] = temp;
                     }
                 }
             }
         }

      ### **9. Imprimiendo el i-ésimo número por el principio y el i-ésimo por el final**
         int[] numeros = {1, 2, 3, 4, 5};
         for (int i = 0; i < numeros.length / 2; i++) {
             System.out.println("Inicio: " + numeros[i] + ", Fin: " + numeros[numeros.length - 1 - i]);
         }

      ### **10. Combinar dos arreglos en un tercero**
         int[] arr1 = {1, 2, 3};
         int[] arr2 = {4, 5, 6};
         int[] combinado = new int[arr1.length + arr2.length];
         System.arraycopy(arr1, 0, combinado, 0, arr1.length);
         System.arraycopy(arr2, 0, combinado, arr1.length, arr2.length);
         System.out.println(Arrays.toString(combinado)); // [1, 2, 3, 4, 5, 6]

      ### **11. Combinar dos arreglos en un tercero con múltiples elementos**
         int[] arr1 = {1, 2, 3};
         int[] arr2 = {4, 5, 6, 7, 8};
         int[] combinado = new int[arr1.length + arr2.length];
         System.arraycopy(arr1, 0, combinado, 0, arr1.length);
         System.arraycopy(arr2, 0, combinado, arr1.length, arr2.length);
         System.out.println(Arrays.toString(combinado));

      ### **12. Obtener el número mayor de un arreglo de enteros**
         int[] numeros = {3, 8, 1, 5, 9};
         int mayor = numeros[0];
         for (int num : numeros) {
             if (num > mayor) mayor = num;
         }
         System.out.println("Mayor: " + mayor);

      ### **13. Detectar orden del arreglo**
         int[] numeros = {1, 2, 3, 4, 5};
         boolean ordenado = true;
         for (int i = 0; i < numeros.length - 1; i++) {
             if (numeros[i] > numeros[i + 1]) {
                 ordenado = false;
                 break;
             }
         }
         System.out.println("Está ordenado: " + ordenado);

      ### **14. Copiar pares e impares de un arreglo de enteros a sus respectivos arreglos**
         int[] numeros = {1, 2, 3, 4, 5, 6};
         List<Integer> pares = new ArrayList<>();
         List<Integer> impares = new ArrayList<>();

         for (int num : numeros) {
             if (num % 2 == 0) {
                 pares.add(num);
             } else {
                 impares.add(num);
             }
         }
         System.out.println("Pares: " + pares);
         System.out.println("Impares: " + impares);

      ### **15. Sistema de notas de alumnos por asignaturas**
         String[] alumnos = {"Juan", "Ana", "Luis"};
         String[] asignaturas = {"Matemáticas", "Historia", "Ciencias"};
         int[][] notas = {
             {90, 80, 70}, // Notas de Juan
             {85, 75, 95}, // Notas de Ana
             {88, 92, 84}  // Notas de Luis
         };

         for (int i = 0; i < alumnos.length; i++) {
             System.out.println("Notas de " + alumnos[i] + ":");
             for (int j = 0; j < asignaturas.length; j++) {
                 System.out.println("  " + asignaturas[j] + ": " + notas[i][j]);
             }
         }

      ### **16. Buscar elementos en un arreglo**
         int[] numeros = {1, 3, 5, 7, 9};
         int buscar = 5;
         boolean encontrado = false;

         for (int num : numeros) {
             if (num == buscar) {
                 encontrado = true;
                 break;
             }
         }
         System.out.println(buscar + " encontrado: " + encontrado);

      ### **17. Mover los elementos desde el inicio hasta el final**
         int[] numeros = {1, 2, 3, 4, 5};
         int temp = numeros[0];
         for (int i = 0; i < numeros.length - 1; i++) {
             numeros[i] = numeros[i + 1];
         }
         numeros[numeros.length - 1] = temp;
         System.out.println(Arrays.toString(numeros)); // [2, 3, 4, 5, 1]

      ### **18. Agregar un elemento en una posición indicada y mover los siguientes**
         int[] numeros = {1, 2, 3, 4, 5};
         int nuevo = 10;
         int posicion = 2;
         int[] resultado = new int[numeros.length + 1];

         for (int i = 0; i < posicion; i++) {
             resultado[i] = numeros[i];
         }
         resultado[posicion] = nuevo;
         for (int i = posicion; i < numeros.length; i++) {
             resultado[i + 1] = numeros[i];
         }
         System.out.println(Arrays.toString(resultado)); // [1, 2, 10, 3, 4, 5]

      ### **19. Agregar un elemento manteniendo el arreglo ordenado**
         int[] numeros = {1, 3, 5, 7};
         int nuevo = 4;
         int[] resultado = new int[numeros.length + 1];
         boolean insertado = false;

         for (int i = 0, j = 0; i < numeros.length; i++, j++) {
             if (!insertado && nuevo < numeros[i]) {
                 resultado[j] = nuevo;
                 insertado = true;
                 j++;
             }
             resultado[j] = numeros[i];
         }
         if (!insertado) resultado[resultado.length - 1] = nuevo;
         System.out.println(Arrays.toString(resultado)); // [1, 3, 4, 5, 7]

      ### **20. Eliminar un elemento del arreglo**
         int[] numeros = {1, 2, 3, 4, 5};
         int eliminar = 3;
         int[] resultado = new int[numeros.length - 1];

         for (int i = 0, j = 0; i < numeros.length; i++) {
             if (numeros[i] != eliminar) {
                 resultado[j++] = numeros[i];
             }
         }
         System.out.println(Arrays.toString(resultado)); // [1, 2, 4, 5]

      ### **21. Insertar un nuevo elemento e incrementar el tamaño del arreglo**
         int[] numeros = {1, 2, 3, 4};
         int nuevo = 5;
         int[] resultado = new int[numeros.length + 1];

         System.arraycopy(numeros, 0, resultado, 0, numeros.length);
         resultado[resultado.length - 1] = nuevo;

         System.out.println(Arrays.toString(resultado)); // [1, 2, 3, 4, 5]

   13. Matrices: Arreglos bidimensionales

      ### **1. ¿Qué son las matrices?**
         Una **matriz** en Java es un arreglo bidimensional (2D), es decir, una tabla con filas y columnas que almacena elementos del mismo tipo.
         Por ejemplo:
         1  2  3
         4  5  6
         7  8  9
         Es una matriz de 3 filas y 3 columnas.

      ### **2. Declaración e instanciación**
         Para declarar e instanciar una matriz:
         int[][] matriz = new int[3][3]; // Matriz de 3 filas y 3 columnas
         - `int[][]` es el tipo.
         - `[3][3]` especifica el tamaño: 3 filas y 3 columnas.

      ### **3. Tamaños de filas y columnas**
         El tamaño se refiere a la cantidad de filas y columnas de una matriz. Por ejemplo:
         int filas = matriz.length;       // Número de filas
         int columnas = matriz[0].length; // Número de columnas en la primera fila

      ### **4. Inicialización de elementos**
         Podemos inicializar una matriz directamente:
         int[][] matriz = {
             {1, 2, 3},
             {4, 5, 6},
             {7, 8, 9}
         };
         O inicializar cada elemento manualmente:
         matriz[0][0] = 1; // Fila 0, Columna 0
         matriz[1][2] = 6; // Fila 1, Columna 2

      ### **5. Obtener elementos**
         Para acceder a un elemento, usa índices:
         int valor = matriz[2][1]; // Obtiene el elemento en Fila 2, Columna 1
         System.out.println(valor); // Imprime 8

      ### **6. Declaración, instanciación e inicialización**
         Todo en una sola línea:
         int[][] matriz = {
             {1, 2, 3},
             {4, 5, 6},
             {7, 8, 9}
         };

      ### **7. Recorrer una matriz usando `for`**
         Un bucle anidado para recorrer filas y columnas:
         for (int i = 0; i < matriz.length; i++) {           // Recorrer filas
             for (int j = 0; j < matriz[i].length; j++) {    // Recorrer columnas
                 System.out.print(matriz[i][j] + " ");
             }
             System.out.println(); // Salto de línea por fila
         }

      ### **8. Tamaños de columnas variables en una matriz**
         En Java, las columnas pueden tener tamaños diferentes:
         int[][] matriz = new int[3][];
         matriz[0] = new int[2]; // Fila 0 con 2 columnas
         matriz[1] = new int[3]; // Fila 1 con 3 columnas
         matriz[2] = new int[1]; // Fila 2 con 1 columna

      ### **9. Buscar un elemento en una matriz usando etiquetas y `break`**
         int[][] matriz = {
             {1, 2, 3},
             {4, 5, 6},
             {7, 8, 9}
         };
         int buscado = 5;
         boolean encontrado = false;

         buscar:
         for (int i = 0; i < matriz.length; i++) {
             for (int j = 0; j < matriz[i].length; j++) {
                 if (matriz[i][j] == buscado) {
                     System.out.println("Encontrado en: [" + i + "][" + j + "]");
                     encontrado = true;
                     break buscar; // Salir de ambos bucles
                 }
             }
         }

      ### **10. Ejecutar en modo depuración**
         1. Usa tu IDE (Eclipse, IntelliJ, o VSCode).
         2. Coloca un punto de interrupción en una línea de tu código.
         3. Ejecuta en modo **depuración** (Debug) para inspeccionar la matriz paso a paso.

      ### **11. Matriz simétrica**
         Una matriz es simétrica si es igual a su transpuesta. Ejemplo de verificación:
         boolean esSimetrica = true;
         for (int i = 0; i < matriz.length; i++) {
             for (int j = 0; j < matriz[i].length; j++) {
                 if (matriz[i][j] != matriz[j][i]) {
                     esSimetrica = false;
                     break;
                 }
             }
         }
         System.out.println("¿Es simétrica? " + esSimetrica);

      ### **12. Convertir a matriz transpuesta**
         La **transpuesta** de una matriz se obtiene intercambiando filas por columnas:
         int[][] transpuesta = new int[matriz[0].length][matriz.length];
         for (int i = 0; i < matriz.length; i++) {
             for (int j = 0; j < matriz[i].length; j++) {
                 transpuesta[j][i] = matriz[i][j];
             }
         }

      ### **13. Operaciones aritméticas en matrices**
         Ejemplo: suma de dos matrices:
         int[][] suma = new int[3][3];
         for (int i = 0; i < matriz1.length; i++) {
             for (int j = 0; j < matriz1[i].length; j++) {
                 suma[i][j] = matriz1[i][j] + matriz2[i][j];
             }
         }

      ### **14. Sumar filas y columnas**
         Suma de filas:
         for (int i = 0; i < matriz.length; i++) {
             int sumaFila = 0;
             for (int j = 0; j < matriz[i].length; j++) {
                 sumaFila += matriz[i][j];
             }
             System.out.println("Suma de fila " + i + ": " + sumaFila);
         }

         Suma de columnas:
         for (int j = 0; j < matriz[0].length; j++) {
             int sumaColumna = 0;
             for (int i = 0; i < matriz.length; i++) {
                 sumaColumna += matriz[i][j];
             }
             System.out.println("Suma de columna " + j + ": " + sumaColumna);
         }

      ### **15. Límites inferior y superior y la diagonal principal**
         - **Límite inferior**: Elementos en la parte inferior de la diagonal principal.
         - **Diagonal principal**: Elementos donde el índice de fila y columna coinciden (`matriz[i][i]`).

         for (int i = 0; i < matriz.length; i++) {
             System.out.println("Diagonal principal: " + matriz[i][i]);
         }

   14. Programación orientada a objetos: Clases y objetos
   15. Programación orientada a objetos: Paquetes
   16. Programación orientada a objetos: Ejemplo Facturas
   17. Programación orientada a objetos: Sobrecarga de métodos
   18. Programación orientada a objetos: Herencia
   19. Programación orientada a objetos: Herencia y clases Abstractas
   20. Programación orientada a objetos: Interfaces
   21. Programación orientada a objetos: Ejemplo interface Repositorio
   22. Tipos Genéricos (Java Generics)
   23. Manejo de Excepciones
   24. Estructura de Datos: API de Colección de Java
   25. Threads: Hilos y Concurrencia
   26. Java 8 Programación Funcional: Expresiones Lambda
   27. Java 8 Programación Funcional: API Stream
   28. Java 8 Programación Funcional: Optional
   29. Java 8 Date Time
   30. Java Annotations: Uso de Anotaciones
   31. Recursividad
   32. Manejo de Archivos
   34. Bases de datos con JDBC
   35. Bases de datos con JDBC: Pool de conexiones
   36. Bases de datos con JDBC: Transacciones
   37. Unit Testing: JUnit 5
   38. Unit Testing: Mockito


Recursos Alternos:
   Youtube:
      https://www.youtube.com/@ProgramandoConElNovato
      https://youtu.be/2ZXiuh0rg3M?si=lH38v7V0C28GSmuM
